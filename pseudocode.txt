Pseudocode: Traffic Data Processing and Analysis Tool

Author: B.G Ranuga Gamage  
Date: 03/12/2024  
Student ID: 20231264  

Main Functions

1. `validate_inputs`
Prompts and validates user inputs based on general validations and specific requirements.  
- Inputs:  
  - `general_validations` - A dictionary of lambdas for general checks (e.g., is numeric).  
  - `requirements` - A dictionary with prompts and specific validations.  
- Outputs: List of validated inputs.  
- Steps:  
  1. Define a lambda to apply general validations on text input.
  2. Iterate through the `requirements`.  
  3. Prompt the user for input and validate it using both general and specific rules.  
  4. Repeat until all inputs are valid.  
  5. Return validated inputs.

2. `validate_date_input`
Prompts for a date and validates it.  
- Inputs: None.  
- Outputs: Validated day, month, and year.  
- Steps:  
  1. Define general and specific validation rules for day, month, and year.  
  2. Call `validate_inputs` with these rules.  
  3. Generate a file path for the given date using `get_csv_file_name`.  
  4. If the file path is invalid, restart the process.  
  5. Return the validated date.

3. `validate_continue_input` 
Prompts for a "Y" or "N" input to continue processing.  
- Inputs: None.  
- Outputs: Validated response ("Y" or "N").  
- Steps:  
  1. Define a validation rule for "Y" or "N".  
  2. Call `validate_inputs`.  
  3. Return the validated response.

4. `get_csv_file_name`
Generates a file name based on the date.  
- Inputs: `day`, `month`, `year`.  
- Outputs: File path string.  
- Steps:  
  1. Concatenate inputs in the format: `"traffic_data{day}{month}{year}.csv"`.  
  2. Return the string.

5. `valid_path` 
Checks if the file exists in the current directory.  
- Inputs: `file_path`.  
- Outputs: Boolean (`True` if valid, `False` otherwise).  
- Steps:  
  1. List all files in the current directory.  
  2. Check if `file_path` is present in the list.  
  3. Return the result.

6. `load_csv_file`
Loads and parses a CSV file into a dictionary.  
- Inputs: `file_path`.  
- Outputs: Dictionary with column headers as keys and rows as lists.  
- Steps:  
  1. Open the file and read the first line as headers.  
  2. Initialize a dictionary with headers as keys and empty lists as values.  
  3. Read remaining lines and populate the dictionary.  
  4. Return the dictionary.

Data Processing Functions

7. `access_specific_data`
Filters data based on column values.  
- Inputs: `data`, `column`, `equal_value`.  
- Outputs: List of indices matching the condition.  
- Steps:  
  1. Iterate through the column's values.  
  2. Return indices where values match `equal_value`.

8. `get_hour_count`
Counts occurrences by hour.  
- Inputs: `data`, `idxs`.  
- Outputs: Dictionary of hours and their counts.  
- Steps:  
  1. Iterate through `idxs` to get hours.  
  2. Increment the count for each hour.  
  3. Return the dictionary.

9. `process_csv_data`
Processes CSV data and computes required metrics.  
- Inputs: `file_path`.  
- Outputs: Dictionary of calculated metrics.  
- Steps:  
  1. Load data using `load_csv_file`.  
  2. Define metric calculations using lambda functions.  
  3. Iterate through requirements to compute metrics.  
  4. Identify peak hours using `get_hour_count`.  
  5. Return all metrics and peak hour information.

Display and Save Functions

10. `display_outcomes`
Displays metrics in a formatted way.  
- Inputs: `outcomes`.  
- Outputs: None.  
- Steps:  
  1. Iterate through `outcomes`.  
  2. Print each metric and its value.

11. `save_results_to_file`
Saves outcomes to a text file.  
- Inputs: `outcomes`, `file_name`.  
- Outputs: None.  
- Steps:  
  1. Open the file in append mode.  
  2. Write the outcomes in a structured format.

Execution Flow

1. Prompt for a valid date using `validate_date_input`.  
2. Generate the corresponding CSV file name.  
3. Load and process the CSV file using `process_csv_data`.  
4. Display the results using `display_outcomes`.  
5. Save the results to a text file using `save_results_to_file`.  
6. Prompt to continue or exit using `validate_continue_input`.  
7. Repeat the process if the user opts to continue.
